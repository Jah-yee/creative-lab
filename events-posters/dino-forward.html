<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DINO RUN — Forward</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #f7f7f7;
    overflow: hidden;
    font-family: 'Press Start 2P', monospace;
    width: 100vw; height: 100vh;
    display: flex; align-items: center; justify-content: center;
    image-rendering: pixelated;
  }
  #game-wrapper {
    position: relative; width: 600px; height: 600px; background: #f7f7f7;
  }
  #gameCanvas {
    position: absolute; top: 0; left: 0; width: 600px; height: 600px;
    image-rendering: pixelated; z-index: 1;
  }
  #webcamVideo {
    position: absolute; bottom: 8px; right: 8px;
    width: 120px; height: 90px; border: 2px solid #535353;
    z-index: 10; object-fit: cover; transform: scaleX(-1);
    opacity: 0.85; image-rendering: auto;
  }
  #poseCanvas {
    position: absolute; bottom: 8px; right: 8px;
    width: 120px; height: 90px; z-index: 11; pointer-events: none;
  }
  #action-indicator {
    position: absolute; bottom: 106px; right: 8px; width: 120px;
    z-index: 12; text-align: center; font-size: 7px; color: #535353;
    pointer-events: none; line-height: 1.6;
  }
  #action-indicator .al { display: inline-block; padding: 2px 5px; border: 1px solid #535353; background: #f7f7f7; margin: 1px; }
  #action-indicator .al.on { background: #535353; color: #f7f7f7; }
  #score-display {
    position: absolute; top: 12px; right: 12px; z-index: 15;
    font-size: 10px; color: #535353; letter-spacing: 1px; text-align: right;
  }
  #hi-score { font-size: 8px; opacity: 0.5; margin-bottom: 4px; }
  #intro-overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 100; background: #f7f7f7;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    text-align: center; cursor: pointer;
  }
  #intro-overlay .title { font-size: 16px; color: #535353; margin-bottom: 24px; letter-spacing: 3px; }
  #intro-overlay .sub { font-size: 7px; color: #535353; margin-bottom: 40px; line-height: 2.2; max-width: 420px; opacity: 0.65; }
  #intro-overlay .hint { font-size: 8px; color: #535353; animation: bk 1.2s infinite; }
  #intro-overlay .cam-st { font-size: 7px; color: #999; margin-top: 16px; }
  @keyframes bk { 0%,100%{opacity:1} 50%{opacity:0.2} }
  #death-msg {
    position: absolute; top: 48%; left: 50%; transform: translate(-50%, 0);
    z-index: 50; font-size: 8px; color: #535353; text-align: center;
    display: none; line-height: 2.4; pointer-events: none;
  }
</style>
</head>
<body>
<div id="game-wrapper">
  <canvas id="gameCanvas" width="600" height="600"></canvas>
  <video id="webcamVideo" autoplay playsinline muted></video>
  <canvas id="poseCanvas" width="120" height="90"></canvas>
  <div id="action-indicator">
    <span class="al" id="lj">↑ JUMP</span>
    <span class="al" id="ld">↓ DUCK</span>
    <span class="al" id="lr">● RUN</span>
  </div>
  <div id="score-display">
    <div id="hi-score">HI 00000</div>
    <div id="cur-score">00000</div>
  </div>
  <div id="death-msg"></div>
  <div id="intro-overlay">
    <div class="title">D I N O &nbsp; R U N</div>
    <div class="sub">
      STAND IN FRONT OF YOUR CAMERA<br>
      JUMP WITH YOUR BODY TO CLEAR OBSTACLES<br>
      CROUCH DOWN TO DODGE LOW BARRIERS<br><br>
      KEYBOARD FALLBACK: ↑ JUMP &nbsp;&nbsp; ↓ DUCK
    </div>
    <div class="hint">[ PRESS SPACE OR JUMP TO START ]</div>
    <div class="cam-st" id="cam-status">INITIALIZING CAMERA...</div>
  </div>
</div>
<script>
(function(){
'use strict';

const CVS = document.getElementById('gameCanvas');
const CTX = CVS.getContext('2d');
const W = 600, H = 600;
const PX = '#535353';
const BG = '#f7f7f7';

// ======================== PIXEL SPRITE FACTORY ========================
function mkC(w, h, fn) {
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  fn(c.getContext('2d'), w, h);
  return c;
}

// Dino back-view sprites (running away from camera toward horizon)
const dino = {
  run1: mkC(44, 47, (c) => {
    c.fillStyle = PX;
    // head
    c.fillRect(14,0,16,8); c.fillRect(12,2,2,4); c.fillRect(30,2,2,4);
    // neck + torso
    c.fillRect(16,8,12,4); c.fillRect(10,12,24,14);
    // arms
    c.fillRect(8,15,2,7); c.fillRect(34,15,2,7);
    // shoulders
    c.fillRect(18,10,8,2);
    // tail
    c.fillRect(19,26,6,4);
    // legs frame1
    c.fillRect(12,26,6,12); c.fillRect(26,26,6,12);
    c.fillRect(11,38,8,4); c.fillRect(26,38,7,4);
    // eyes
    c.fillRect(15,3,3,2); c.fillRect(26,3,3,2);
    c.fillStyle = BG;
    c.fillRect(16,3,1,1); c.fillRect(27,3,1,1);
  }),
  run2: mkC(44, 47, (c) => {
    c.fillStyle = PX;
    c.fillRect(14,0,16,8); c.fillRect(12,2,2,4); c.fillRect(30,2,2,4);
    c.fillRect(16,8,12,4); c.fillRect(10,12,24,14);
    c.fillRect(8,15,2,7); c.fillRect(34,15,2,7);
    c.fillRect(18,10,8,2); c.fillRect(19,26,6,4);
    // legs frame2
    c.fillRect(14,26,6,12); c.fillRect(24,26,6,12);
    c.fillRect(14,38,7,4); c.fillRect(23,38,8,4);
    c.fillRect(15,3,3,2); c.fillRect(26,3,3,2);
    c.fillStyle = BG;
    c.fillRect(16,3,1,1); c.fillRect(27,3,1,1);
  }),
  jump: mkC(44, 47, (c) => {
    c.fillStyle = PX;
    c.fillRect(14,0,16,8); c.fillRect(12,2,2,4); c.fillRect(30,2,2,4);
    c.fillRect(16,8,12,4); c.fillRect(10,12,24,14);
    // arms raised
    c.fillRect(6,8,2,10); c.fillRect(36,8,2,10);
    c.fillRect(18,10,8,2); c.fillRect(19,26,6,3);
    // legs tucked
    c.fillRect(13,26,6,8); c.fillRect(25,26,6,8);
    c.fillRect(15,3,3,2); c.fillRect(26,3,3,2);
    c.fillStyle = BG;
    c.fillRect(16,3,1,1); c.fillRect(27,3,1,1);
  }),
  duck: mkC(50, 24, (c) => {
    c.fillStyle = PX;
    // flat wide body
    c.fillRect(5,0,40,6); c.fillRect(9,6,32,8);
    // head peek
    c.fillRect(17,0,16,3);
    // legs
    c.fillRect(14,14,6,6); c.fillRect(30,14,6,6);
    c.fillRect(13,20,8,4); c.fillRect(29,20,8,4);
    // eyes
    c.fillRect(19,1,3,1); c.fillRect(28,1,3,1);
  }),
  dead: mkC(44, 47, (c) => {
    c.fillStyle = PX;
    c.fillRect(14,0,16,8); c.fillRect(12,2,2,4); c.fillRect(30,2,2,4);
    c.fillRect(16,8,12,4); c.fillRect(10,12,24,14);
    c.fillRect(18,10,8,2); c.fillRect(19,26,6,4);
    c.fillRect(12,26,6,14); c.fillRect(26,26,6,14);
    // X eyes
    c.fillRect(15,2,1,1); c.fillRect(17,4,1,1); c.fillRect(16,3,1,1);
    c.fillRect(27,2,1,1); c.fillRect(29,4,1,1); c.fillRect(28,3,1,1);
    // arms flung out
    c.fillRect(3,16,7,2); c.fillRect(34,16,7,2);
  })
};

// Cactus sprites
function mkCactus(sz) {
  if (sz === 's') return mkC(17, 35, (c) => {
    c.fillStyle = PX;
    c.fillRect(6,0,5,28); c.fillRect(0,8,6,5); c.fillRect(11,14,6,5);
    c.fillRect(0,8,3,12); c.fillRect(14,12,3,10); c.fillRect(4,28,9,4);
    c.fillRect(5,2,1,1); c.fillRect(12,5,1,1); c.fillRect(2,16,1,1);
  });
  return mkC(25, 50, (c) => {
    c.fillStyle = PX;
    c.fillRect(9,0,7,40); c.fillRect(0,10,9,6); c.fillRect(16,18,9,6);
    c.fillRect(0,10,4,18); c.fillRect(21,16,4,16);
    c.fillRect(6,40,13,6); c.fillRect(4,42,17,4);
    c.fillRect(8,3,1,1); c.fillRect(17,7,1,1); c.fillRect(2,22,1,1);
  });
}
const cactS = mkCactus('s'), cactL = mkCactus('l');

// Barrier (duck to pass)
const barrier = mkC(56, 18, (c) => {
  c.fillStyle = PX;
  c.fillRect(0,5,56,4); // bar
  c.fillRect(2,0,4,18); c.fillRect(50,0,4,18); // posts
  c.fillRect(6,2,44,2); c.fillRect(6,12,44,2); // wires
  c.fillRect(8,7,40,2); // mid wire
});

// Cloud
const cloud = mkC(46, 14, (c) => {
  c.fillStyle = PX; c.globalAlpha = 0.25;
  c.fillRect(10,0,26,3); c.fillRect(6,3,34,4); c.fillRect(0,6,46,4); c.fillRect(4,10,38,4);
});

// ======================== GAME STATE ========================
const S = {
  phase: 'intro',
  speed: 2.5, maxSpeed: 8.5, accel: 0.0015,
  score: 0, hi: 0, time: 0, fc: 0,
  dy: 0, dvy: 0, // dino Y offset (0=ground, neg=air)
  ducking: false, jumping: false,
  obs: [], clouds: [], rlines: [],
  lastOZ: 0, goff: 0, reason: ''
};

// Constants
const HORIZON_Y = 170;
const GROUND_Y = 545;
const VP_X = W / 2, VP_Y = HORIZON_Y;
const GRAV = 0.5;
const JVEL = -11.5;
const RD_W_NEAR = 340, RD_W_FAR = 50;

// Perspective math
function z2y(z) { return VP_Y + (GROUND_Y - VP_Y) * (1 - z); }
function z2s(z) { return Math.max(0.08, 1 - z * 0.88); }
function rdW(z) { return RD_W_FAR + (RD_W_NEAR - RD_W_FAR) * (1 - z); }

// ======================== CV SYSTEM ========================
let cvOk = false, cvJ = false, cvD = false, cvBase = null, cvSY = 0, detector = null;

async function initCV() {
  const st = document.getElementById('cam-status');
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240, facingMode: 'user' }});
    const vid = document.getElementById('webcamVideo');
    vid.srcObject = stream; await vid.play();
    st.textContent = 'CAMERA READY — LOADING POSE MODEL...';
    await loadPose(vid, st);
  } catch(e) { st.textContent = 'NO CAMERA — USE KEYBOARD ↑↓'; }
}

async function loadPose(vid, st) {
  try {
    await ldS('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.17.0/dist/tf-core.min.js');
    await ldS('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.17.0/dist/tf-converter.min.js');
    await ldS('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.17.0/dist/tf-backend-webgl.min.js');
    await ldS('https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.min.js');
    await tf.setBackend('webgl'); await tf.ready();
    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
    );
    st.textContent = 'POSE READY — STAND STILL TO CALIBRATE';
    cvOk = true;
    poseLoop(vid);
  } catch(e) { st.textContent = 'POSE FAILED — USE KEYBOARD'; }
}

function ldS(src) {
  return new Promise((r, j) => {
    if (document.querySelector('script[src="'+src+'"]')) { r(); return; }
    const s = document.createElement('script'); s.src = src; s.onload = r; s.onerror = j;
    document.head.appendChild(s);
  });
}

const SM = 0.3, JTH = 0.11, DTH = 0.09, DEB = 120;
let ljt = 0, ldt = 0;

async function poseLoop(vid) {
  if (!detector || !cvOk) return;
  try {
    const poses = await detector.estimatePoses(vid);
    if (poses.length > 0) {
      const k = poses[0].keypoints;
      const nose = k[0], ls = k[5], rs = k[6], lh = k[11], rh = k[12];
      if (nose.score > 0.3 && ls.score > 0.3 && rs.score > 0.3) {
        const shY = (ls.y + rs.y) / 2;
        const hpY = (lh.score > 0.2 && rh.score > 0.2) ? (lh.y + rh.y) / 2 : shY + 80;
        const bh = hpY - nose.y;
        const cy = (nose.y + shY) / 2;
        cvSY = cvSY * (1 - SM) + cy * SM;
        if (!cvBase && S.phase !== 'playing') cvBase = { y: cvSY, h: bh };
        if (cvBase) {
          const d = cvSY - cvBase.y, rel = d / cvBase.h, now = performance.now();
          if (rel < -JTH && now - ljt > DEB) { cvJ = true; cvD = false; ljt = now; }
          else if (rel > DTH && now - ldt > DEB) { cvD = true; cvJ = false; ldt = now; }
          else if (Math.abs(rel) < 0.05) { cvJ = false; cvD = false; }
        }
        drawPose(k);
      }
    }
  } catch(e) {}
  requestAnimationFrame(() => poseLoop(vid));
}

function drawPose(k) {
  const pc = document.getElementById('poseCanvas').getContext('2d');
  pc.clearRect(0, 0, 120, 90);
  const sx = 120/320, sy = 90/240;
  const conn = [[5,6],[5,7],[7,9],[6,8],[8,10],[5,11],[6,12],[11,12],[11,13],[13,15],[12,14],[14,16]];
  pc.strokeStyle = cvJ ? '#2a2' : cvD ? '#c33' : PX;
  pc.lineWidth = 1;
  conn.forEach(([a,b]) => {
    if (k[a].score > 0.2 && k[b].score > 0.2) {
      pc.beginPath(); pc.moveTo(k[a].x*sx, k[a].y*sy); pc.lineTo(k[b].x*sx, k[b].y*sy); pc.stroke();
    }
  });
  k.forEach(p => { if (p.score > 0.2) { pc.fillStyle = PX; pc.fillRect(p.x*sx-1, p.y*sy-1, 3, 3); }});
}

// ======================== INPUT ========================
const keys = {};
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    if (S.phase === 'intro') start();
    else if (S.phase === 'dead') start();
  }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });
document.getElementById('intro-overlay').addEventListener('click', () => { if (S.phase === 'intro') start(); });
CVS.addEventListener('click', () => { if (S.phase === 'dead') start(); });

function jP() { return keys['Space'] || keys['ArrowUp'] || cvJ; }
function dP() { return keys['ArrowDown'] || cvD; }

// ======================== GAME CONTROL ========================
function start() {
  S.phase = 'playing'; S.score = 0; S.speed = 2.5; S.time = 0; S.fc = 0;
  S.dy = 0; S.dvy = 0; S.ducking = false; S.jumping = false;
  S.obs = []; S.clouds = []; S.rlines = []; S.lastOZ = 0; S.goff = 0; S.reason = '';
  cvBase = null; cvSY = 0;
  for (let i = 0; i < 14; i++) S.rlines.push({ z: i / 14 });
  for (let i = 0; i < 6; i++) S.clouds.push({ x: Math.random() * W, z: Math.random(), ph: Math.random() * 6.28 });
  document.getElementById('intro-overlay').style.display = 'none';
  document.getElementById('death-msg').style.display = 'none';
}

function die(r) {
  S.phase = 'dead'; S.reason = r || '';
  if (S.score > S.hi) S.hi = S.score;
  const el = document.getElementById('death-msg');
  el.innerHTML = 'G A M E &nbsp; O V E R<br><span style="font-size:6px;opacity:0.55;line-height:3">' + r + '<br>TAP OR PRESS SPACE</span>';
  el.style.display = 'block';
}

// ======================== UPDATE ========================
function update(dt) {
  if (S.phase !== 'playing') return;
  S.time += dt; S.fc++;
  if (S.speed < S.maxSpeed) S.speed += S.accel * dt;
  S.score += S.speed * dt * 0.018;

  // Dino physics
  if (jP() && !S.jumping && S.dy >= 0) { S.dvy = JVEL; S.jumping = true; S.ducking = false; }
  if (S.jumping) { S.dvy += GRAV; S.dy += S.dvy; if (S.dy >= 0) { S.dy = 0; S.dvy = 0; S.jumping = false; } }
  S.ducking = !S.jumping && dP();

  // Obstacles
  const mv = S.speed * dt * 0.0009;
  S.obs.forEach(o => o.z -= mv);
  S.obs = S.obs.filter(o => o.z > -0.12);
  S.lastOZ -= mv;

  const gap = Math.max(0.22, 0.48 - S.speed * 0.025);
  if (S.lastOZ < (1 - gap) && S.time > 1800) {
    const r = Math.random();
    const type = r < 0.28 ? 'cs' : r < 0.58 ? 'cl' : 'bar';
    const lane = (Math.random() - 0.5) * 0.35;
    S.obs.push({ type, z: 1.05, lane, hit: false });
    S.lastOZ = 1.05;
  }

  // Collision
  S.obs.forEach(o => {
    if (o.hit || o.z > 0.14 || o.z < 0.01) return;
    if (Math.abs(o.lane) < 0.16) {
      if (o.type === 'bar') {
        if (!S.ducking) { o.hit = true; die('DUCK TO DODGE BARRIERS ↓'); }
      } else {
        if (S.dy > -28) { o.hit = true; die(o.type === 'cl' ? 'NEED HIGHER JUMP ↑' : 'JUMP TO AVOID ↑'); }
      }
    }
  });

  // Clouds
  S.clouds.forEach(c => {
    c.z -= mv * 0.25;
    c.x += Math.sin(S.time * 0.0008 + c.ph) * 0.12;
    if (c.z < -0.1) { c.z = 1; c.x = Math.random() * W; c.ph = Math.random() * 6.28; }
  });

  // Road lines
  S.rlines.forEach(l => { l.z -= mv; if (l.z < 0) l.z += 1; });
  S.goff = (S.goff + S.speed * dt * 0.04) % 64;
}

// ======================== RENDER ========================
function render() {
  CTX.fillStyle = BG; CTX.fillRect(0, 0, W, H);

  // Sky
  const sg = CTX.createLinearGradient(0, 0, 0, VP_Y);
  sg.addColorStop(0, '#f7f7f7'); sg.addColorStop(1, '#f0f0f0');
  CTX.fillStyle = sg; CTX.fillRect(0, 0, W, VP_Y);

  // Horizon line
  CTX.strokeStyle = PX; CTX.globalAlpha = 0.12; CTX.lineWidth = 1;
  CTX.beginPath(); CTX.moveTo(0, VP_Y); CTX.lineTo(W, VP_Y); CTX.stroke();
  CTX.globalAlpha = 1;

  // Clouds (far to near)
  S.clouds.sort((a,b) => b.z - a.z).forEach(c => {
    if (c.z < 0 || c.z > 1) return;
    const sc = z2s(c.z) * 0.7;
    const cy = VP_Y - 90 * (1 - c.z) - 15;
    CTX.save(); CTX.globalAlpha = 0.12 + 0.12 * (1 - c.z);
    CTX.drawImage(cloud, c.x - 23*sc, cy, 46*sc, 14*sc);
    CTX.restore();
  });

  // Ground perspective lines
  drawGround();

  // Road dashes
  CTX.fillStyle = PX;
  S.rlines.forEach(l => {
    if (l.z < 0.01 || l.z > 0.99) return;
    const sy = z2y(l.z), sc = z2s(l.z);
    CTX.globalAlpha = 0.08 * (1 - l.z * 0.6);
    CTX.fillRect(VP_X - 1.5*sc, sy - 6*sc, 3*sc, 6*sc);
  });
  CTX.globalAlpha = 1;

  // Obstacles (far first)
  [...S.obs].sort((a,b) => b.z - a.z).forEach(o => {
    if (o.z < -0.05 || o.z > 1.1) return;
    drawObs(o);
  });

  // Dino
  drawDino();

  // Warnings
  if (S.phase === 'playing') drawWarn();

  // HUD
  document.getElementById('cur-score').textContent = String(Math.floor(S.score)).padStart(5,'0');
  document.getElementById('hi-score').textContent = 'HI ' + String(Math.floor(S.hi)).padStart(5,'0');

  const lj = document.getElementById('lj'), ld = document.getElementById('ld'), lr = document.getElementById('lr');
  lj.className = 'al' + (S.jumping ? ' on' : '');
  ld.className = 'al' + (S.ducking ? ' on' : '');
  lr.className = 'al' + (!S.jumping && !S.ducking && S.phase === 'playing' ? ' on' : '');
}

function drawGround() {
  CTX.save();
  // Converging road edges
  for (let z = 0; z < 1; z += 0.015) {
    const sy = z2y(z), rw = rdW(z);
    CTX.strokeStyle = PX;
    CTX.globalAlpha = 0.05 + 0.05 * (1 - z);
    CTX.lineWidth = Math.max(0.4, 1.2 * (1 - z));
    // Left edge
    CTX.beginPath(); CTX.moveTo(VP_X - rw/2, sy); CTX.lineTo(VP_X - rw/2, sy + 1.5); CTX.stroke();
    // Right edge
    CTX.beginPath(); CTX.moveTo(VP_X + rw/2, sy); CTX.lineTo(VP_X + rw/2, sy + 1.5); CTX.stroke();
  }
  // Horizontal scan lines for ground texture
  for (let z = 0; z < 1; z += 0.04) {
    const zz = (z + (S.goff / 64) * 0.04) % 1;
    const sy = z2y(zz), rw = rdW(zz) * 2;
    CTX.strokeStyle = PX;
    CTX.globalAlpha = 0.025 * (1 - zz);
    CTX.lineWidth = Math.max(0.3, 0.8 * (1 - zz));
    CTX.beginPath(); CTX.moveTo(VP_X - rw/2, sy); CTX.lineTo(VP_X + rw/2, sy); CTX.stroke();
  }
  CTX.restore();
}

function drawObs(o) {
  const sy = z2y(o.z), sc = z2s(o.z), rw = rdW(o.z);
  const ox = VP_X + o.lane * rw;
  let spr, dw, dh;
  if (o.type === 'cs') { spr = cactS; dw = 17*sc*1.6; dh = 35*sc*1.6; }
  else if (o.type === 'cl') { spr = cactL; dw = 25*sc*1.6; dh = 50*sc*1.6; }
  else { spr = barrier; dw = 56*sc*1.5; dh = 18*sc*1.5; }

  // Near-boost
  if (o.z < 0.2) { const b = 1 + (0.2 - o.z) * 0.6; dw *= b; dh *= b; }

  const dx = ox - dw/2, dy = sy - dh;

  // Reaction zone outline
  if (o.z > 0.14 && o.z < 0.38 && S.phase === 'playing') {
    CTX.save();
    CTX.globalAlpha = 0.07 * (1 - (o.z - 0.14) / 0.24);
    CTX.strokeStyle = PX; CTX.lineWidth = 1.5; CTX.setLineDash([3,3]);
    CTX.strokeRect(dx - 3, dy - 3, dw + 6, dh + 6);
    CTX.setLineDash([]); CTX.restore();
  }

  CTX.save();
  CTX.globalAlpha = Math.min(1, 0.25 + 0.75 * (1 - o.z));
  CTX.drawImage(spr, dx, dy, dw, dh);
  CTX.restore();
}

function drawDino() {
  const ds = 1.9;
  let spr, sh;
  if (S.phase === 'dead') { spr = dino.dead; sh = 47; }
  else if (S.jumping) { spr = dino.jump; sh = 47; }
  else if (S.ducking) { spr = dino.duck; sh = 24; }
  else { spr = (Math.floor(S.fc / 5) % 2 === 0) ? dino.run1 : dino.run2; sh = 47; }

  const sw = (S.ducking ? 50 : 44) * ds;
  const dh = sh * ds;
  const dx = W/2 - sw/2;
  const baseY = GROUND_Y - 16;
  const jOff = S.dy * 2.8;
  const dy = baseY - dh + jOff;

  // Jump shadow
  if (S.jumping && S.phase === 'playing') {
    CTX.save();
    CTX.globalAlpha = 0.06 * Math.min(1, -S.dy / 40);
    CTX.fillStyle = PX;
    const sw2 = sw * (1 + S.dy * 0.005);
    CTX.beginPath();
    CTX.ellipse(W/2, baseY, sw2/2.5, 4, 0, 0, Math.PI * 2);
    CTX.fill();
    CTX.restore();
  }

  CTX.drawImage(spr, dx, dy, sw, dh);
}

function drawWarn() {
  S.obs.filter(o => o.z > 0.28 && o.z < 0.55).forEach(o => {
    const sy = z2y(o.z), sc = z2s(o.z);
    const lbl = o.type === 'bar' ? '↓ DUCK' : '↑ JUMP';
    const al = 0.35 * (1 - (o.z - 0.28) / 0.27);
    CTX.save();
    CTX.globalAlpha = al; CTX.fillStyle = PX;
    CTX.font = '7px "Press Start 2P", monospace';
    CTX.textAlign = 'center';
    CTX.fillText(lbl, VP_X, sy - 25 * sc);
    CTX.restore();
  });
}

// ======================== LOOP ========================
let lt = 0;
function loop(t) {
  const dt = lt ? Math.min(t - lt, 50) : 16;
  lt = t;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

initCV();
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
